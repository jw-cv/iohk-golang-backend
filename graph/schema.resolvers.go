package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.54

import (
	"context"
	"fmt"
	"iohk-golang-backend-preprod/graph/model"
	"strconv"
)

// Query Resolvers

func (r *queryResolver) Customer(ctx context.Context, id string) (*model.Customer, error) {
	for _, customer := range r.customers {
		if customer.ID == id {
			return customer, nil
		}
	}
	return nil, fmt.Errorf("customer not found")
}

func (r *queryResolver) Customers(ctx context.Context) ([]*model.Customer, error) {
	return r.customers, nil
}

// Mutation Resolvers

func (r *mutationResolver) CreateCustomer(ctx context.Context, input model.CreateCustomerInput) (*model.Customer, error) {
	customer := &model.Customer{
		ID:         strconv.Itoa(r.nextID),
		Name:       input.Name,
		Surname:    input.Surname,
		Number:     input.Number,
		Gender:     input.Gender,
		Country:    input.Country,
		Dependants: input.Dependants,
		BirthDate:  input.BirthDate,
	}

	r.customers = append(r.customers, customer)
	r.nextID++

	return customer, nil
}

func (r *mutationResolver) UpdateCustomer(ctx context.Context, id string, input model.UpdateCustomerInput) (*model.Customer, error) {
	for i, customer := range r.customers {
		if customer.ID == id {
			if input.Name != nil {
				customer.Name = *input.Name
			}
			if input.Surname != nil {
				customer.Surname = *input.Surname
			}
			if input.Number != nil {
				customer.Number = *input.Number
			}
			if input.Gender != nil {
				customer.Gender = *input.Gender
			}
			if input.Country != nil {
				customer.Country = *input.Country
			}
			if input.Dependants != nil {
				customer.Dependants = *input.Dependants
			}
			if input.BirthDate != nil {
				customer.BirthDate = *input.BirthDate
			}
			r.customers[i] = customer
			return customer, nil
		}
	}
	return nil, fmt.Errorf("customer not found")
}

func (r *mutationResolver) DeleteCustomer(ctx context.Context, id string) (bool, error) {
	for i, customer := range r.customers {
		if customer.ID == id {
			r.customers = append(r.customers[:i], r.customers[i+1:]...)
			return true, nil
		}
	}
	return false, fmt.Errorf("customer not found")
}

// Resolver type assertions
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }
func (r *Resolver) Query() QueryResolver       { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
